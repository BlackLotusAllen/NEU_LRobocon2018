//void RunTask(void)
//{
//	CPU_INT08U os_err;
//	os_err = os_err;                                                 //防报错
//	OS_CPU_SR cpu_sr;
//	OS_ENTER_CRITICAL(); /*互斥访问*/
//	int last_pdate = cnt;
//	OS_EXIT_CRITICAL();
//	int pdate_now = last_pdate;
//	static int cnt1 = 100;
//	while(1)
//	{
//		OSSemPend(CPUUsageSem,0,&os_err);		
//		cnt1--;
//		OS_CPU_SR cpu_sr;
//		OS_ENTER_CRITICAL();                                          /*互斥访问*/
//		pdate_now = cnt;
//		OS_EXIT_CRITICAL();
//		if(pdate_now != last_pdate)
//		{
//			USART_OUT(UART4,(uint8_t*)"CPU load is: %d",cnt1);
//			USART_SendData(UART4,'%');
//			USART_SendData(UART4,'\r');
//			USART_SendData(UART4,'\n');
//			cnt1 = 100;
//			last_pdate = pdate_now;
//		}
//		OSSemSet(CPUUsageSem, 0, &os_err);                            	 //信号量归零               
//	}

//	os_err = OSTaskCreate((void (*)(void *))RunTask,
//						  (void *)0,
//						  (OS_STK *)&RunTaskStk[RUN_TASK_STK_SIZE-1],
//						  (INT8U)RUN_TASK_PRIO);	  

///u8 isOKFlag = 0;
//u8 issendOK = 0;
//float angle = 0;
//extern float error;

//union u8andfloat
//{   
//	uint8_t data[24];
//	float ActVal[6];  
//}posture;

//union
//{
//	uint8_t data[24];
//	float ActVal[6];
//}receieve;
//void USART3_IRQHandler(void) //更新频率 200Hz 
//{ 
//	static uint8_t ch;  	  
//	static uint8_t count = 0;
//	static uint8_t i = 0;
//	OS_CPU_SR cpu_sr;
//	OS_ENTER_CRITICAL(); /* Tell uC/OS-II that we are starting an ISR*/
//	OSIntNesting++;
//	OS_EXIT_CRITICAL();
//	if(USART_GetITStatus(USART3,USART_IT_ORE_ER) ==SET) 
//	{   
//		USART_ClearITPendingBit(USART3,USART_IT_ORE_ER);
//		USART_ReceiveData(USART3);  
//	}   
//	if (USART_GetITStatus(USART3, USART_IT_RXNE) == SET)  
//	{   
//		USART_ClearITPendingBit(USART3, USART_IT_RXNE);   
//		ch = USART_ReceiveData(USART3);   
//		switch (count)   
//		{   
//		case 0:    
//			if (ch == 0x0d)	count++;    
//			else if(ch=='O') count=5;    
//			else count = 0;    
//			break;  
//		case 1:    
//			if (ch == 0x0a)    
//			{     
//				i = 0;    
//				count++;    
//			}    
//			else count = 0;   
//			break;  
//		case 2:    
//			receieve.data[i] = ch;  
//			i++;   
//			if (i >= 24)  
//			{   
//				i = 0;  
//				count++;  
//			}    
//			break;  
//		case 3:   
//			if (ch == 0x0a) count++;  
//			else count = 0;  
//			break;  
//		case 4:  
//			if (ch == 0x0d)  
//			{    
//				#if CarNumber == 4
//				OS_CPU_SR cpu_sr;
//				OS_ENTER_CRITICAL();                                         /*互斥访问*/
//				posture.ActVal[0] = receieve.ActVal[0] ;//角度    
//				posture.ActVal[1] = receieve.ActVal[1];    
//				posture.ActVal[2] = receieve.ActVal[2];     
//				posture.ActVal[3] = receieve.ActVal[3]+error;//x    
//				posture.ActVal[4] = receieve.ActVal[4];//y      
//				posture.ActVal[5] = receieve.ActVal[5];
//				OS_EXIT_CRITICAL();
//				#elif CarNumber == 1
//				OS_CPU_SR cpu_sr;
//				OS_ENTER_CRITICAL();   
//				posture.ActVal[0] = -receieve.ActVal[0] ;//角度    
//				posture.ActVal[1] = receieve.ActVal[1];    
//				posture.ActVal[2] = receieve.ActVal[2];     
//				posture.ActVal[3] = receieve.ActVal[4]+error;//x  
//				posture.ActVal[4] = -receieve.ActVal[3];//y 				     
//				posture.ActVal[5] = receieve.ActVal[5];			
//				OS_EXIT_CRITICAL();
//				#endif
//		//		SetXpos(posX);     
//		//		SetYpos(posY);     
//		//		SetAngle(angle);    
//			} 			
//			issendOK = 1;
//			count = 0;    
//			break;   
//		case 5:    
//			count = 0;    
//			if(ch=='K')     
//			isOKFlag=1;    
//			break;        
//		default:    
//			count = 0; 
//			break;   
//		}  
//	}  
//	else  
//	{   
//		USART_ClearITPendingBit(USART3, USART_IT_RXNE);   
//		USART_ReceiveData(USART3); 
//	}       
//	OSIntExit();
//}
//	

//u8 isOKSend(void)
//{
//	return isOKFlag;
//}

//void resetOK(void)
//{
//	isOKFlag = 0;
//}
/						  (INT8U)Walk_TASK_PRIO);

//void USART3_IRQHandler(void) //更新频率200Hz
//{
//	static uint8_t ch;
//	static union {
//		uint8_t data[24];
//		float ActVal[6];
//	} posture;
//	static uint8_t count = 0;
//	static uint8_t i = 0;
//	OS_CPU_SR cpu_sr;
//	OS_ENTER_CRITICAL(); /* Tell uC/OS-II that we are starting an ISR*/
//	OSIntNesting++;
//	OS_EXIT_CRITICAL();

//	if (USART_GetITStatus(USART3, USART_IT_RXNE) == SET)
//	{
//		USART_ClearITPendingBit(USART3, USART_IT_RXNE);
//		ch = USART_ReceiveData(USART3);
//		switch (count)
//		{
//		case 0:
//			if (ch == 0x0d)
//				count++;
//			else
//				count = 0;
//			break;

//		case 1:
//			if (ch == 0x0a)
//			{
//				i = 0;
//				count++;
//			}
//			else if (ch == 0x0d)
//				;
//			else
//				count = 0;
//			break;

//		case 2:
//			posture.data[i] = ch;
//			i++;
//			if (i >= 24)
//			{
//				i = 0;
//				count++;
//			}
//			break;

//		case 3:
//			if (ch == 0x0a)
//				count++;
//			else
//				count = 0;
//			break;

//		case 4:
//			if (ch == 0x0d)
//			{

//				angle = posture.ActVal[0];
//				posture.ActVal[1] = posture.ActVal[1];
//				posture.ActVal[2] = posture.ActVal[2];
//				posture.ActVal[3] = posture.ActVal[3];
//				posture.ActVal[4] = posture.ActVal[4];
//				posture.ActVal[5] = posture.ActVal[5];
//			}
//			count = 0;
//			break;

//		default:
//			count = 0;
//			break;
//		}
//	}
//	else
//	{
//		USART_ClearITPendingBit(USART3, USART_IT_PE);
//		USART_ClearITPendingBit(USART3, USART_IT_TXE);
//		USART_ClearITPendingBit(USART3, USART_IT_TC);
//		USART_ClearITPendingBit(USART3, USART_IT_ORE_RX);
//		USART_ClearITPendingBit(USART3, USART_IT_IDLE);
//		USART_ClearITPendingBit(USART3, USART_IT_LBD);
//		USART_ClearITPendingBit(USART3, USART_IT_CTS);
//		USART_ClearITPendingBit(USART3, USART_IT_ERR);
//		USART_ClearITPendingBit(USART3, USART_IT_ORE_ER);
//		USART_ClearITPendingBit(USART3, USART_IT_NE);
//		USART_ClearITPendingBit(USART3, USART_IT_FE);
//		USART_ReceiveData(USART3);
//	}
//	OSIntExit();
//}

//void USART3_IRQHandler(void)
//{
//	OS_CPU_SR cpu_sr;
//	OS_ENTER_CRITICAL(); /* Tell uC/OS-II that we are starting an ISR*/
//	OSIntNesting++;
//	OS_EXIT_CRITICAL();

//	if (USART_GetITStatus(USART3, USART_IT_RXNE) == SET)
//	{
//		USART_ClearITPendingBit(USART3, USART_IT_RXNE);
//	}

//	OSIntExit();
//}










void USART3_IRQHandler(void) 
{
	static uint8_t ch;
	static union {
		uint8_t data[24];
		float ActVal[6];
	} posture;
	static uint8_t count = 0;
	static uint8_t i = 0;
	OS_CPU_SR cpu_sr;
	OS_ENTER_CRITICAL(); /* Tell uC/OS-II that we are starting an ISR*/
	OSIntNesting++;
	OS_EXIT_CRITICAL();

	if(USART_GetITStatus(USART3, USART_IT_ORE_ER) == SET)
	{
		USART_ClearITPendingBit(USART3, USART_IT_ORE_ER);
		USART_ReceiveData(USART3);
	}
	
	if(USART_GetITStatus(USART3, USART_IT_RXNE) == SET)
	{
		USART_ClearITPendingBit(USART3, USART_IT_RXNE);
		ch = USART_ReceiveData(USART3);
		switch(count)
		{
		case 0:
			if(ch == 0x0d)
				count++;
			else if(ch == 'O')
                count = 5;
			else
				count = 0;
			break;

		case 1:
			if(ch == 0x0a)
			{
				i = 0;
				count++;
			}
			else if(ch == 0x0d)
			{
				
			}
			else
				count = 0;
			break;

		case 2:
			posture.data[i] = ch;
			i++;
			if(i >= 24)
			{
				i = 0;
				count++;
			}
			break;

		case 3:
			if(ch == 0x0a)
				count++;
			else
				count = 0;
			break;

		case 4:
			if(ch == 0x0d)
			{
				opsFlag = 1;
				pos.angle = posture.ActVal[0];
				posture.ActVal[1] = posture.ActVal[1];
				posture.ActVal[2] = posture.ActVal[2];
				pos.x=posture.ActVal[3];
	            pos.y=posture.ActVal[4];
				posture.ActVal[5] = posture.ActVal[5];	
			}
			count = 0;
			break;
		case 5:
            count = 0;
 		    if(ch == 'K')
				isOKFlag = 1;
            break;

		default:
			count = 0;
			break;
		}
	}
	else
	{
		USART_ClearITPendingBit(USART3, USART_IT_RXNE);
		USART_ReceiveData(USART3);
	}
	OSIntExit();	
}






/**
* @brief  PID控制参数数据结构体
* @author 陈昕炜
* @note   定义一个PID_Value类型，此时PID_Value为一个数据类型标识符，数据类型为结构体
*/
typedef struct{
	float setValue;      //系统待调节量的设定值 
    float feedbackValue; //系统待调节量的反馈值，就是传感器实际测量的值    
     
    float Kp;            //比例系数
    float Ki;            //积分系数
    float Kd;            //微分系数
        
    float error;         //当前偏差
    float error_1;       //前一步的偏差
	float error_sum;     //偏差累计
	float error_def;     //当前偏差与上一偏差的差值
    
    float output;        //PID控制器的输出
    float out_max;       //输出上限
    float out_min;       //输出下限
}PID_Value;

PID_Value PID_Angle_;

/**
* @brief  PID控制器
* @param  *p 要进行计算输出的PID控制数据结构体指针
* @author 陈昕炜
* @note   用于PID中
*/
float PID_operation(PID_Value *p)
{
	p->Kp = 0.02;
	p->Ki = 0;
	p->Kd = 0.001;	
	p->error = p->setValue - p->feedbackValue;
	p->error_sum = p->error_sum + p->error;
	p->error_def = p->error - p->error_1;
	p->error_1 = p->error;
	p->output = p->Kp * p->error + p->Ki * p->error_sum + p->Kd * p->error_def;
	return p->output;
}

/**
* @brief  浮点数限幅
* @param  amt：需要进行限幅的数
* @param  high：输出上限
* @param  low：输出下限
* @author 陈昕炜
* @note   constrain ->约束，限制
*/
float constrain_float(float amt, float high, float low) 
{
    return ((amt)<(low)?(low):((amt)>(high)?(high):(amt)));
}
/**
* @brief  转速差实现转弯函数
* @param  speed：两车轮圆心连线中点的移动速度 单位米
* @param  radius：两车轮圆心连线中点的转弯半径 单位米
* @param  mode：转弯模式 1为右转弯 2为左转弯 3为向前直走
* @param  slowwheel：内侧轮的设定值
* @param  fastwheel：外侧轮的设定值
* @author 陈昕炜
* @note   用于WalkTask中
*/
void Go(float velocity, float radius, char mode)
{
	float slowwheel, fastwheel;
	//设定值 = 速度 * ( 转弯半径 - 车轮距离的一半）/ 转弯半径 * 车轮一米每秒的设定值
	slowwheel = velocity * (1000 * radius - WHEEL_TREAD / 2) / (1000 * radius) * One_Meter_Per_Second;
    fastwheel = velocity * (1000 * radius + WHEEL_TREAD / 2) / (1000 * radius) * One_Meter_Per_Second;
	if(mode == 1)//右转弯
	{
		VelCrl(CAN2, 1, (int)slowwheel);
		VelCrl(CAN2, 2, (int)(fastwheel * -1));
	}
	if(mode == 2)//左转弯
	{
		VelCrl(CAN2, 1, (int)fastwheel);
		VelCrl(CAN2, 2, (int)(slowwheel * -1));
	}
	if(mode == 3)//直走
	{
		VelCrl(CAN2, 1, (int)(velocity * One_Meter_Per_Second));
		VelCrl(CAN2, 2, (int)(velocity * One_Meter_Per_Second * -1));
	}
}
/*
一个脉冲是4096/(120*Pi)
定义输入速度mm/s和半径mm
*/
float ratio1,ratio2;
void vel_radious(float vel,float radious)
{
	ratio1=(radious+WHEEL_TREAD/2)/radious;
	ratio2=(radious-WHEEL_TREAD/2)/radious;
	VelCrl(CAN2,1,ratio1*vel*Pulse2mm);
	VelCrl(CAN2,2,-ratio2*vel*Pulse2mm);
}


/*


//void ConfigTask(void)
//{
//	CPU_INT08U os_err;
//	os_err = os_err;
//	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
//	TIM_Init(TIM2,1000-1,84-1,1,3);	//产生10ms中断，抢占优先级为1，响应优先级为3

//	CAN_Config(CAN1,500,GPIOB,GPIO_Pin_8,GPIO_Pin_9);
//	CAN_Config(CAN2,500,GPIOB,GPIO_Pin_5,GPIO_Pin_6);
//	
//	VelLoopCfg(CAN2,1, 5000, 5000);				//驱动器速度环初始化
//	VelLoopCfg(CAN2,2, 5000, 5000);
//	
//	ElmoInit(CAN2);								//驱动器初始化
//	MotorOn(CAN2,1);							//电机使能（通电）
//	MotorOn(CAN2,2);
//	
//	
//	TIM_Init(TIM2, 999, 83, 0, 0);
//	USART3_Init(115200);
//	UART4_Init(921600);
//	
//	ElmoInit(CAN2);
//	VelLoopCfg(CAN2, 1, 2333333, 2333333);
//	VelLoopCfg(CAN2, 2, 2333333, 2333333);
//	MotorOn(CAN2, 1);
//	MotorOn(CAN2, 2);
//	//一号车定位系统初始化
//	if(CarNum == CarOne)
//	{
//		delay_s(2);
//		driveGyro();
//		while(!opsFlag);
//	}
//	//四号车定位系统初始化
//	if(CarNum == CarFour)
//	{
//		delay_s(10);
//	}
//	OSTaskSuspend(OS_PRIO_SELF);	
//}

//int cntTurn = 0, cntSendTime = 0;
//char switchNextModeFlag = 1, adjustFlag = 0, turnFlag = 0;
//float adjustVelocity, baseVelocity;

//void WalkTask(void)
//{
//	int cntSendTime;
//	CPU_INT08U os_err;
//	os_err = os_err;
//	tar.angle = pos.angle;

//	OSSemSet(PeriodSem, 0, &os_err);
//	while (1)
//	{

//		OSSemPend(PeriodSem, 0, &os_err);

//		
//		//以50 * 10ms为间隔发送数据
//		cntSendTime++;
//		cntSendTime = cntSendTime % 50;
//		if(cntSendTime == 1)
//		{
//            USART_OUT(UART4, (uint8_t*)"x=%d,y=%d,ang=%d,tx=%d,ty=%d,ta=%d,cT=%d,tF=%d\r\n", (int)pos.x, (int)pos.y, (int)pos.angle,(int)tar.x, (int)tar.y, (int)tar.angle, (int)cntTurn, (int)turnFlag);
//		}
//		
//        //到达目标地点后，turnFlag = 1开始转弯
//		if(cntTurn == 0)
//		{
//            if(tar.x > pos.x){turnFlag = 1;}
//		}
//		if(cntTurn == 1)
//		{	
//			if(tar.y > pos.y){turnFlag = 1;}
//		}
//		if(cntTurn == 2)
//		{	
//			if(tar.x < pos.x){turnFlag = 1;}
//		}
//		if(cntTurn == 3)
//		{
//			if(tar.y < pos.y){turnFlag = 1;}
//		}
//		
//		//设置转弯目标角度
//		if(turnFlag == 1)
//		{
//			
//			switch (cntTurn)
//		    {
//		    case 0:
//			    tar.angle = -90;
//			    break;
//		    case 1:
//			    tar.angle = -180;			    
//			    break;
//		    case 2:
//			    tar.angle = 90;			
//			    break;
//		    case 3:
//			    tar.angle = 0;					
//			    break;
//		    }
//		}
//		
//		//转弯时速度值完全由PID输出，直线行驶时加上基础速度
//		if(turnFlag == 1)
//		{
//			baseVelocity = 0;
//		}
//		if(turnFlag == 0)
//		{
//			baseVelocity = BaseVelocity;
//		}
//		
//        //根据当前角度正负调整目标角度，使转弯圆弧始终为劣弧
//		if(tar.angle == 180 || tar.angle == -180)
//		{
//			if(pos.angle > 0)
//			{
//				tar.angle = 180;
//			}
//			if(pos.angle < 0)
//			{
//				tar.angle = -180;
//			}
//		}
//		
//	    
//		PID_Angle_.setValue = tar.angle;
//        PID_Angle_.feedbackValue = pos.angle;		
//		PID_Angle_.error = PID_Angle_.setValue - PID_Angle_.feedbackValue;

////		adjustVelocity = PID_operation(&PID_Angle) * One_Meter_Per_Second;//逆时针旋转时，四号车adjustVelocity为负数
//		//adjustVelocity = constrain_float(adjustVelocity, PID_Angle.out_max, PID_Angle.out_min);
//		
//		VelCrl(CAN2, 1, (int)(baseVelocity - adjustVelocity));//右轮
//		VelCrl(CAN2, 2, (int)((baseVelocity + adjustVelocity) * -1));//左轮

//		//角度误差在允许范围内时停止转弯turnFlag = 0，设置下一个目标的位置信息switchNextModeFlag = 1，转弯计数加1
//		int Angle_Error_Range = 1;
//		if((fabs(tar.angle - pos.angle) < Angle_Error_Range) && (turnFlag == 1))
//		{
//			turnFlag = 0;
//			switchNextModeFlag = 1;
//			cntTurn++;
//		}
//		cntTurn = cntTurn % 4;
//		//设置下一个目标的位置信息
//		if(switchNextModeFlag == 1)
//		{
//			switchNextModeFlag = 0;
//			switch (cntTurn)
//		    {
//		    case 0:
//				tar.x = pos.x - Side_Length;
//			    tar.y = pos.y;
//			    tar.angle = 0;
//			    break;
//		    case 1:
//				tar.x = pos.x;
//			    tar.y = pos.y - Side_Length;
//			    tar.angle = -90;			    
//			    break;
//		    case 2:
//				tar.x = pos.x + Side_Length;
//			    tar.y = pos.y;
//			    tar.angle = -180;			
//			    break;
//		    case 3:
//				tar.x = pos.x;
//			    tar.y = pos.y + Side_Length;
//			    tar.angle = 90;					
//			    break;
//		    }
//		}
//		OSSemSet(PeriodSem, 0, &os_err);

//		vel_radious(500.0,500.0);			//半径为0.5m，速度为0.5m/s

//	}
//}
*/

///*
//=========================================================================
//							直行
//					入口参数：速度,单位mm/s
//=========================================================================
//*/
//void WalkStraight(int v)                             
//{
//	VelCrl(CAN2,1,(4096/378)*v);
//	VelCrl(CAN2,2,-((4096/378)*v));
//}
///*
//=========================================================================
//						    画圈
//入口参数;               前进方向  ACW  or  CW;
//                       轴中间的速度 v 单位mm/s
//                        圈的半径  r   单位mm
//=========================================================================
//*/
//void WalkRound(u8 direction4, int v,int r)           //画圈，入口参数
//{
//	int w = v/r;
//	if(direction4 == CW)
//	{
//		VelCrl(CAN2,1,(4096/378)*(w*(r-217)));
//		VelCrl(CAN2,2,-((4096/378)*(w*(r+217))));
//	}
//	else
//	{
//		VelCrl(CAN2,1,(4096/378)*(w*(r+217)));
//		VelCrl(CAN2,2,-((4096/378)*(w*(r-217))));
//	}
//}

///*
//=========================================================================
//                       PID控制――底盘
//误差分析：	1.车轮打滑（1m/s刹车有100mm误差）；
//			2.定位系统陀螺仪漂移（两圈1度左右）；
//			3.车速导致的转弯误差（1m/s转弯有250mm）；
//			4.PID角度超调（0.05左右的超调）；
//			5.PID坐标函数应用在直线PID上时不好控制误差；
//			6.车轮有最大加速度（经不完全计算大概）
//			7.以后如果需要提高精度，可以考虑把PID函数控制精度改为0.1mm/s
//========================================================================
//*/

//float angle_set = 0;
//extern u8 isOKFlag;
//extern u8 issendOK;
//float kp = 20;
//float ki = 0.01;
//float kd = 40;
//float lastAngle = 0;
//float velocity = 0;
//float ITerm = 0;
//float velocityMax1 = 3600;
//float velocityMax2 = -3600;
//float velocityMin1 = 100;
//float velocityMin2 = -100;
//u8 squareCnt = 0;
//extern float angle;
//u8 coordinateCnt = 0;
////void driveGyro(void)                                                 //1车定位系统使能
////{
////	while(!isOKFlag)
////	{
////		TIM_Delayms(TIM4,5);
////		USART_SendData(USART3,'A');
////		USART_SendData(USART3,'T');
////		USART_SendData(USART3,'\r');
////		USART_SendData(USART3,'\n');
////	}
////	isOKFlag = 0;
////	while(!issendOK);
////	issendOK = 0;
////}

//void SetTunings(float p,float i,float d)                             //kp，ki，kd设置函数
//{
//	kp = p;
//	ki = i;
//	kd = d;
//}

//void Init_PID(float angle)                                           //PID参数初始化（重开pid时需要用到）
//{
//	lastAngle = angle;
//	ITerm = velocity;
//    if(ITerm > velocityMax1) ITerm= velocityMax1;
//    else if(ITerm < velocityMax2) ITerm= velocityMax2;
//}

//void PID_Angle(u8 status,float Angle_Set,float Angle,float v)          //PID角度控制，使车头锁定一个固定方向
//{
//	static u8 lastStatus = 0;
//	if(status == manual)
//	{
//		lastStatus = status;
//		return;
//	}
//	if(lastStatus == manual && status == Auto) Init_PID(Angle);	
//	if(Angle_Set>180) Angle_Set = Angle_Set - 360;
//	if(Angle_Set<-180) Angle_Set = Angle_Set + 360;	
//	if(Angle_Set>=0)
//	{
//		if(Angle>=Angle_Set-180) Angle = Angle-Angle_Set;
//		else Angle = Angle + 360 - Angle_Set;
//	}
//	if(Angle_Set<0)
//	{
//		if(Angle<=Angle_Set+180) Angle = Angle-Angle_Set;
//		else Angle = Angle - 360 - Angle_Set;
//	}
////	if(Angle_Set - lastAngle>10 || Angle_Set - lastAngle<-10)
//	float error = 0 - Angle;
//	if(error>3 || error<-3) 
//	{
//		ki = 0.001;
//		kd = 20;
//	}
//	else 
//	{
//		ki = 0.01;
//		kd = 1000;
//	}
//	ITerm += ki*error;
//	if(ITerm > velocityMax1) ITerm= velocityMax1;
//    if(ITerm < velocityMax2) ITerm= velocityMax2;
////	if(ITerm > 0 && ITerm < velocityMin1) ITerm = velocityMin1;
////	if(ITerm < 0 && ITerm > velocityMin2) ITerm = velocityMin2;
//	float DTerm = lastAngle - Angle;
//	velocity = kp*error + ITerm + kd*DTerm;
//	v = v/((abs((int)(DTerm*8)))+1);
//	if(velocity > velocityMax1) velocity = velocityMax1;
//    if(velocity < velocityMax2) velocity = velocityMax2;
////	if(velocity > 0 && velocity < velocityMin1) velocity = velocityMin1;
////  if(velocity < 0 && velocity > velocityMin2) velocity = velocityMin2;
//	lastAngle = Angle;
//	lastStatus = status;
//	VelCrl(CAN2,1,(int)(((4096/378)*velocity)+(4096/378)*v));
//	VelCrl(CAN2,2,(int)(((4096/378)*velocity)-(4096/378)*v));
//}

//extern union u8andfloat                                              //引用定位系统数据
//{   
//	uint8_t data[24];
//	float ActVal[6];
//}posture;

//void PID_Coordinate(float x0,float y0,float v)                         //PID坐标控制，引导车子驶向一个固定坐标
//{
//	if(posture.ActVal[3]>x0 && posture.ActVal[4]>y0) PID_Angle(Auto,(90+((atan((posture.ActVal[4]-y0)/(posture.ActVal[3]-x0)))*(180/3.141592))),posture.ActVal[0],v);
//	if(posture.ActVal[3]>x0 && posture.ActVal[4]<y0) PID_Angle(Auto,(90-((atan((y0-posture.ActVal[4])/(posture.ActVal[3]-x0)))*(180/3.141592))),posture.ActVal[0],v);
//	if(posture.ActVal[3]<x0 && posture.ActVal[4]>y0) PID_Angle(Auto,(-90-((atan((posture.ActVal[4]-y0)/(x0-posture.ActVal[3])))*(180/3.141592))),posture.ActVal[0],v);
//	if(posture.ActVal[3]<x0 && posture.ActVal[4]<y0) PID_Angle(Auto,(-90+((atan((y0-posture.ActVal[4])/(x0-posture.ActVal[3])))*(180/3.141592))),posture.ActVal[0],v);
//	if(posture.ActVal[3]==x0 && posture.ActVal[4]<y0) PID_Angle(Auto,0,posture.ActVal[0],v);
//	if(posture.ActVal[3]==x0 && posture.ActVal[4]>=y0) PID_Angle(Auto,180,posture.ActVal[0],v);
////	if((x0-50)<posture.ActVal[3] && posture.ActVal[3]<(x0+50) && (y0-50)<posture.ActVal[4] && posture.ActVal[4]<(y0+50)) coordinateCnt++;
//}

//void PID_Line(float x1,float y1,float x2,float y2,float v)             //PID直线，保证车子在一条直线上前进
//{
//	float Line_A = y1-y2;
//	float Line_B = x2-x1;
//	float Line_C = x1*y2-x2*y1;
//	float error = (Line_A*posture.ActVal[3]+Line_B*posture.ActVal[4]+Line_C)/sqrt(Line_A*Line_A+Line_B*Line_B);
//	if(error>900) error = 900;
//	if(error<-900) error = -900;
//	if(error>-100 && error<100) kp = 20;
//	else kp = 30;
//	if(x1>x2 && y1>=y2) PID_Angle(Auto,(90+((atan((y1-y2)/(x1-x2)))*(180/3.141592)))-error/20,posture.ActVal[0],v);
//	if(x1>x2 && y1<y2) PID_Angle(Auto,(90-((atan((y2-y1)/(x1-x2)))*(180/3.141592)))-error/20,posture.ActVal[0],v);
//	if(x1<x2 && y1>=y2) PID_Angle(Auto,(-90-((atan((y1-y2)/(x2-x1)))*(180/3.141592)))-error/20,posture.ActVal[0],v);
//	if(x1<x2 && y1<y2) PID_Angle(Auto,(-90+((atan((y2-y1)/(x2-x1)))*(180/3.141592)))-error/20,posture.ActVal[0],v);
//	if(x1==x2 && y2>=y1) 
//	{
//		if((posture.ActVal[3]-x1)<=900 && (posture.ActVal[3]-x1)>=-900) error = posture.ActVal[3]-x1;
//		else if(error>900) error = 900;
//		else if(error<-900) error = -900;
//		if(error>-100 && error<100) kp = 20;
//		else kp = 30;
//		PID_Angle(Auto,0+error/20,posture.ActVal[0],v);
//	}
//	if(x1==x2 && y2<y1)
//	{
//		if((posture.ActVal[3]-x1)<=900 && (posture.ActVal[3]-x1)>=-900) error = posture.ActVal[3]-x1;
//		else if(error>900) error = 900;
//		else if(error<-900) error = -900;
//		if(error>-100 && error<100) kp = 20;
//		else kp = 30;
//		PID_Angle(Auto,180-error/20,posture.ActVal[0],v);
//	}
//}

//void PID_Square(float v)                                             //PID正方形，两米见方，速度1m的参数
//{
//	static u8 lineCnt = 0;
//	switch(lineCnt)
//	{
//		case 0:
//			PID_Line(0,0,0,2000,v);
//			if(posture.ActVal[4]>1340) lineCnt++;
//			break;
//		case 1:
//			PID_Line(0,2000,-2000,2000,v);
//			if(posture.ActVal[3]<-1430) lineCnt++;
//			break;
//		case 2:
//			PID_Line(-2000,2000,-2000,0,v);
//			if(posture.ActVal[4]<650) lineCnt++;
//			break;
//		case 3:
//			PID_Line(-2000,0,0,0,v);
//			if(posture.ActVal[3]>-650) lineCnt++;
//			break;
//		default:
//			lineCnt = 0;
//			break;
//	}	
//}

//void PID_Round(float x0,float y0,float r,float v,u8 direction3)       //PID圆形，可输入圆心，半径，速度，方向
//{
//	float error = sqrt((posture.ActVal[3]-x0)*(posture.ActVal[3]-x0)+(posture.ActVal[4]-y0)*(posture.ActVal[4]-y0))-r;
//	if(error>900) error = 900;
//	if(error<-900) error = -900;
//	if(error>-100 && error<100) SetTunings(20,0,20);
//	else SetTunings(30,0,40);
//	if(direction3 == ACW)
//	{
//		if(posture.ActVal[3]>x0 && posture.ActVal[4]>y0) PID_Angle(Auto,(+((atan((posture.ActVal[4]-y0)/(posture.ActVal[3]-x0)))*(180/3.141592))+error/10),posture.ActVal[0],v);
//		if(posture.ActVal[3]>x0 && posture.ActVal[4]<y0) PID_Angle(Auto,(-((atan((y0-posture.ActVal[4])/(posture.ActVal[3]-x0)))*(180/3.141592))+error/10),posture.ActVal[0],v);
//		if(posture.ActVal[3]<x0 && posture.ActVal[4]>y0) PID_Angle(Auto,(-180-((atan((posture.ActVal[4]-y0)/(x0-posture.ActVal[3])))*(180/3.141592))+error/10),posture.ActVal[0],v);
//		if(posture.ActVal[3]<x0 && posture.ActVal[4]<y0) PID_Angle(Auto,(-180+((atan((y0-posture.ActVal[4])/(x0-posture.ActVal[3])))*(180/3.141592))+error/10),posture.ActVal[0],v);
//		if(posture.ActVal[3]==x0 && posture.ActVal[4]<y0) PID_Angle(Auto,(-90+error/10),posture.ActVal[0],v);
//		if(posture.ActVal[3]==x0 && posture.ActVal[4]>=y0) PID_Angle(Auto,(90+error/10),posture.ActVal[0],v);
//	}
//	if(direction3 == CW)
//	{
//		if(posture.ActVal[3]>x0 && posture.ActVal[4]>y0) PID_Angle(Auto,(180+((atan((posture.ActVal[4]-y0)/(posture.ActVal[3]-x0)))*(180/3.141592))-error/10),posture.ActVal[0],v);
//		if(posture.ActVal[3]>x0 && posture.ActVal[4]<y0) PID_Angle(Auto,(180-((atan((y0-posture.ActVal[4])/(posture.ActVal[3]-x0)))*(180/3.141592))-error/10),posture.ActVal[0],v);
//		if(posture.ActVal[3]<x0 && posture.ActVal[4]>y0) PID_Angle(Auto,(-((atan((posture.ActVal[4]-y0)/(x0-posture.ActVal[3])))*(180/3.141592))-error/10),posture.ActVal[0],v);
//		if(posture.ActVal[3]<x0 && posture.ActVal[4]<y0) PID_Angle(Auto,(+((atan((y0-posture.ActVal[4])/(x0-posture.ActVal[3])))*(180/3.141592))-error/10),posture.ActVal[0],v);
//		if(posture.ActVal[3]==x0 && posture.ActVal[4]<y0) PID_Angle(Auto,(90-error/10),posture.ActVal[0],v);
//		if(posture.ActVal[3]==x0 && posture.ActVal[4]>=y0) PID_Angle(Auto,(-90-error/10),posture.ActVal[0],v);
//	}
//}

//void PID_Coordinate_following(float v)                               //PID坐标跟随，y=sinx，未完成(开始时的加速段会有较大振荡)
//{	
//	float x = posture.ActVal[3]+50;
//	float y = 500*sin(x*3.141592f/1000);
//	PID_Coordinate(x,y,v);
//}

//void PID_Square_x(float length,float v,u8 direction2)                                            
//{
//	static u8 lineCnt = 0;
//	float update = 650;
//	if(direction2 == ACW)
//	{
//		switch(lineCnt)
//		{
//			case 0:
//				PID_Line(length/2,0,length/2,2000,v);
//				if(posture.ActVal[4]>(2200+length/2-update)) lineCnt++;
//				break;
//			case 1:
//				PID_Line(2000,2200+length/2,-2000,2200+length/2,v);
//				if(posture.ActVal[3]<(update-length/2)) lineCnt++;
//				break;
//			case 2:
//				PID_Line(0-length/2,2000,0-length/2,0,v);
//				if(posture.ActVal[4]<2200-length/2+update) lineCnt++;
//				break;
//			case 3:
//				PID_Line(-2000,2200-length/2,0,2200-length/2,v);
//				if(length>3000)
//				{
//					if(posture.ActVal[3]>(length)/2-update)
//					{
//						lineCnt=0;
//						squareCnt++;
//					}
//				}
//				else
//				{
//					if(posture.ActVal[3]>(length+1000)/2-update)
//					{
//						lineCnt=0;
//						squareCnt++;
//					}
//				}
//				break;
//			default:
//				lineCnt = 0;			
//				break;
//		}	
//	}
//	if(direction2 == CW)
//	{
//		switch(lineCnt)
//		{
//			case 0:				
//				PID_Line((0-length/2),0,(0-length/2),2000,v);
//				if(posture.ActVal[4]>(2200+length/2-update)) lineCnt++;
//				break;
//			case 1:
//				PID_Line(-2000,2200+length/2,2000,2200+length/2,v);			
//				if(posture.ActVal[3]>(length/2-update)) lineCnt++;
//				break;
//			case 2:				
//				PID_Line(length/2,2000,length/2,0,v);
//				if(posture.ActVal[4]<2200-length/2+update) lineCnt++;
//				break;
//			case 3:
//				PID_Line(0,2200-length/2,-2000,2200-length/2,v);
//				if(length>3000)
//				{
//					if(posture.ActVal[3]<-length/2+update) 
//					{
//						lineCnt=0;
//						squareCnt++;
//					}
//				}
//				else
//				{
//					if(posture.ActVal[3]<-1000-length/2+update) 
//					{
//						lineCnt=0;
//						squareCnt++;
//					}
//				}
//				break;
//			default:
//				lineCnt = 0;
//				break;
//		}
//	}
//}

//void PID_RUN(float v,u8 direction1)
//{	
//	switch(squareCnt)
//	{
//		case 0:
//			PID_Square_x(1500,v,direction1);
//			break;
//		case 1:
//			PID_Square_x(2500,v,direction1);
//			break;
//		case 2:
//			PID_Square_x(3500,v,direction1);
//			break;
//		default:
//			squareCnt = 2;			
//			break;			
//	}
//}

///*
////	int x_last = 0;
////	int y_last = 0;
////	int v = 0;
////			USART_OUT(UART4,(uint8_t*)"angle = %d  ", (int)posture.ActVal[0]);
////			USART_OUT(UART4,(uint8_t*)"x = %d  ", (int)posture.ActVal[3]);
////			USART_OUT(UART4,(uint8_t*)"y = %d  ", (int)posture.ActVal[4]);
////			USART_OUT(UART4,(uint8_t*)"v = %d  ", (int)velocity);
////float angle_change(float angle_1)
////{
////	if(angle_set == 0) return angle_1;
////	if(angle_set == 90)
////	{
////		if(angle_1 < -90) return (360+angle_1);
////		else return angle_1;
////	}
////	if(angle_set == 180)
////	{
////		if(angle_1 < 0) return (360+angle_1);
////		else return angle_1;
////	}
////	if(angle_set == 270)
////	{
////		if(angle_1 < 90) return (360+angle_1);
////		else return angle_1;
////	}
////}
////void PID_Angle(u8 status,float Angle_Set,float Angle,int v)
////{
////	static u8 lastStatus = 0;
////	if(status == manual)
////	{
////		lastStatus = status;
////		return;
////	}
////	if(lastStatus == manual && status == Auto) Init_PID(Angle);
////	float error = Angle_Set - Angle;
////	ITerm += ki*error;
////	if(ITerm > velocityMax1) ITerm= velocityMax1;
////    if(ITerm < velocityMax2) ITerm= velocityMax2;
//////	if(ITerm > 0 && ITerm < velocityMin1) ITerm = velocityMin1;
//////	if(ITerm < 0 && ITerm > velocityMin2) ITerm = velocityMin2;
////	float DTerm = lastAngle - Angle;
////	velocity = kp*error + ITerm + kd*DTerm;
//////	velocity = kp*error + kd*DTerm;
////	if(velocity > velocityMax1) velocity = velocityMax1;
////    if(velocity < velocityMax2) velocity = velocityMax2;
//////	if(velocity > 0 && velocity < velocityMin1) velocity = velocityMin1;
//////  if(velocity < 0 && velocity > velocityMin2) velocity = velocityMin2;
////	lastAngle = Angle;
////	lastStatus = status;
////	VelCrl(CAN2,1,(((4096/378)*(velocity))+(4096/378)*v));
////	VelCrl(CAN2,2,(((4096/378)*(velocity))-(4096/378)*v));
////}

////void PID_Line(float x1,float y1,float x2,float y2,int v)
////{
////	float y = posture.ActVal[4];
////	float x = posture.ActVal[3];
////	static u8 delay_error = 0;
////	static u8 delay_line = 0;
////	static float k = 0;
////	static float y3 = 0;
////	static float x3 = 0;
////	static float y4 = 0;
////	static float error = 0;
////	if(x1==x2)
////	{
////		error = sqrt((x-x1)*(x-x1));
////		if(error < 100) 
////		{
////			delay_error = 0;
////			delay_line++;
////			if(delay_line>0)
////			{
////				PID_Coordinate(x2,y2,v);
////				delay_line = 100;
////			}
////		}
////		else
////		{
////			delay_line = 0;
//////			if(delay_error == 0)
//////			{
////				y4 = y;
//////			}
////			delay_error++;
////			if(delay_error>49)
////			{
////				if((x-x1)>200 || (x-x1)<-200) PID_Coordinate(x2,y4,v);
////				else PID_Coordinate(x2,y4,200);
////				delay_error = 150;
////			}
////			else PID_Coordinate(x2,y2,v);			
////		}
////	}
////	else
////	{
////		k = (y2-y1)/(x2-x1);
////		y3 = k*(x-x1+k*(y-y1))/((k*k+1)+k*k)+y1;
////		x3 = (k*k*x1+x+k*y-k*y1)/((k*k+1)+k*k);
////		error = sqrt((x-x3)*(x-x3)+(y-y3)*(y-y3));
////		if(error<100)
////		{
////			delay_error = 0;
////			delay_line++;
////			if(delay_line>0)
////			{
////				PID_Coordinate(x2,y2,v);
////				delay_line = 100;
////			}
////		}
////		else
////		{
////			delay_line = 0;
//////			if(delay_error == 0)
//////			{				
////				
//////			}
////			delay_error++;
////			if(delay_error>49)
////			{
////				if(error<200) PID_Coordinate(x3,y3,200);
////				else PID_Coordinate(x3,y3,v);
////				delay_error = 150;
////			}
////			else PID_Coordinate(x2,y2,v);
////		}
////	}
////}

////			pid方向
////		if(posture.ActVal[3]-x_last > 1800 || posture.ActVal[3]-x_last < -1800 || posture.ActVal[4]-y_last > 1800 || posture.ActVal[4]-y_last < -1800)
////		{
////			coordinateCnt++;
////			x_last = posture.ActVal[3];
////			y_last = posture.ActVal[4];
////		}
////		
////		switch (coordinateCnt)
////		{
////			case 0:
////				angle_set = 0;
////				v = 0;
////				if(posture.ActVal[0]>-5 && posture.ActVal[0]<5) v=500;
////				PID_Angle(Auto,angle_set,posture.ActVal[0],v);
////				break;
////			case 1:
////				angle_set = 90;
////				v = 0;
////				if(posture.ActVal[0]>85 && posture.ActVal[0]<95) v=500;
////				PID_Angle(Auto,angle_set,posture.ActVal[0],v);
////				break;
////			case 2:
////				angle_set = 180;
////				v = 0;
////				if(posture.ActVal[0]>175 || posture.ActVal[0]<-175) v=500;
////				PID_Angle(Auto,angle_set,posture.ActVal[0],v);
////				break;
////			case 3:
////				angle_set = -90;
////				v = 0;
////				if(posture.ActVal[0]>-95 && posture.ActVal[0]<-85) v=500;
////				PID_Angle(Auto,angle_set,posture.ActVal[0],v);
////				break;
////		}
////		if(coordinateCnt == 4) coordinateCnt=0;

////		
//////pid坐标

////		switch (coordinateCnt)
////		{
////			case 0:
////				PID_Coordinate(0,0,500);
////				break;
////			case 1:
////				PID_Coordinate(1500,1500,500);
////				break;
////			case 2:
////				PID_Coordinate(1000,2000,1000);
////				break;
////			case 3:
////				PID_Coordinate(0,1500,1000);
////				break;
////			case 4:
////				PID_Coordinate(-1000,2000,1000);
////				break;
////			case 5:
////				PID_Coordinate(-1500,1500,1000);
////				break;
////		}
////		if(coordinateCnt == 6) coordinateCnt=0;
//*/




static u8 flag1 = 0;
			static u8 flag2 = 0;
			static int timeCnt = 0;
			timeCnt++;
			if(timeCnt < 200)
			{
				if(flag1 == 0)
				{
					pid->Angle += 180;
					pid->V_Set = -2000;
					PID_Control(pid);
				}
				if((ABS(pid->l->line_Error) < 400) || flag1)
				{
					if(flag1 == 0)
					{
						flag1 = 1;
						pid->Angle -= 180;
					}
					if(flag2 == 0)
					{
						pid->V_Set = 0;
						pid->Line_Cnt += 1;
						if(pid->Line_Cnt == 36) pid->Line_Cnt = 0;
						pid->Line_Num = pid->Line_Order[pid->Line_Cnt];
						PID_Pre(pid);
						if(pid->Line_Num<4 && pid->l->line_Error>800) pid->Line_Cnt -= 1;
						if(pid->Line_Num>3 && pid->l->line_Error>1200) pid->Line_Cnt -= 1;
						if(pid->Line_Cnt == -1) pid->Line_Cnt = 35;
						pid->Line_Num = pid->Line_Order[pid->Line_Cnt];
						PID_Control(pid);
					}
					if((ABS(pid->Error) < 10) || flag2)
					{
						flag2 = 1;
						pid->V_Set = 2000;
						pid->Line_Num = pid->Line_Order[pid->Line_Cnt];
						PID_Control(pid);
						if((ABS(pid->Error) < 10))
						{
							error->flag = 0;
							flag1 = 0;
							flag2 = 0;
							timeCnt = 0;
							pid->V_Set = 2000;
						}
					}
				}
				GO(pid);
				USART_OUT(UART4,(uint8_t*)"%d	", (int)timeCnt);
				USART_OUT(UART4,(uint8_t*)"%d	", (int)flag1);
				USART_OUT(UART4,(uint8_t*)"%d	", (int)flag2);
				USART_OUT(UART4,(uint8_t*)"%d	", (int)pid->Line_Num);
				USART_SendData(UART4,'\r');
				USART_SendData(UART4,'\n');
			}
			else
			{
				error->flag = 0;
				flag1 = 0;
				flag2 = 0;
				timeCnt = 0;
				pid->V_Set = 2000;
				pid->Line_Num = pid->Line_Order[pid->Line_Cnt];
				switch (pid->err_line_num)
				{
					case 0:
						break;
					case 1:
						break;
					case 2:
						break;
					case 3:
						break;
					case 4:
						break;
					default:
						break;
				}
			}
			
void PID_Competition(PID_Value *pid, u8 dir, Err *error)                     //新版走线
{
	static u8 flag = 0;
	if(flag == 0 && dir == Right)
	{
		for(int i = 0;i < 36;i++) pid->Line_Order[i] = line_order3[i];
		pid->Line_Num = pid->Line_Order[pid->Line_Cnt];
		flag = 1;
	}
	if(flag == 0 && dir == Left)
	{
		for(int i = 0;i < 36;i++) pid->Line_Order[i] = line_order4[i];
		pid->Line_Num = pid->Line_Order[pid->Line_Cnt];
		flag = 1;
	}
	if(pid->Line_Num < 17)
	{
		if(error->flag == 0)
		{
			pid->direction = ACW;
			pid->Mode = Line;
			pid->Line_Num = pid->Line_Order[pid->Line_Cnt];
			PID_Control(pid);
			GO(pid);
			pid->Line_Cnt += 1;
			if(pid->Line_Cnt == 36) pid->Line_Cnt = 0;
			pid->Line_Num = pid->Line_Order[pid->Line_Cnt];
			PID_Pre(pid);
			if(pid->Line_Num<4 && pid->l->line_Error>800) pid->Line_Cnt -= 1;
			if(pid->Line_Num>3 && pid->l->line_Error>1200) pid->Line_Cnt -= 1;
			if(pid->Line_Cnt == -1) pid->Line_Cnt = 35;
			pid->Line_Num = pid->Line_Order[pid->Line_Cnt];
			pid->target_Num = pid->Line_Num % 4 + 1;
			if(pid->target_Num == 4) pid->target_Num = 0;
		}
		else
		{
			static int timeCnt = 0;
			timeCnt++;
			if(timeCnt < 200)
			{
				pid->Angle += 180;
				pid->V_Set = -2000;
				PID_Control(pid);
				GO(pid);
			}
			else
			{
				
			}
		}
	}
	else if(pid->Line_Num > 16)
	{
		if(error->flag == 0)
		{
			pid->direction = CW;
			pid->Mode = Line;
			pid->Line_Num = pid->Line_Order[pid->Line_Cnt];
			PID_Control(pid);
			GO(pid);
			pid->Line_Cnt += 1;
			if(pid->Line_Cnt == 36) pid->Line_Cnt = 0;
			pid->Line_Num = pid->Line_Order[pid->Line_Cnt];
			PID_Pre(pid);
			if(pid->Line_Num<21 && pid->l->line_Error<-800) pid->Line_Cnt -= 1;
			if(pid->Line_Num>20 && pid->l->line_Error<-1200) pid->Line_Cnt -= 1;
			if(pid->Line_Cnt == -1) pid->Line_Cnt = 35;
			pid->Line_Num = pid->Line_Order[pid->Line_Cnt];
			pid->target_Num = pid->Line_Num % 4 - 1;
			if(pid->target_Num == -1) pid->target_Num = 3;
		}
		else
		{
			static int timeCnt = 0;
			timeCnt++;
			if(timeCnt < 200)
			{
				pid->Angle += 180;
				pid->V_Set = -2000;
				PID_Control(pid);
				GO(pid);
			}
			else
			{
				
			}
		}
	}
}

void PID_Competition_testVersion(PID_Value *pid, u8 dir)                     //test版走线
{
	static u8 flag = 0;
	if(flag == 0 && dir == Right)
	{
		for(int i = 0;i < 24;i++) pid->Line_Order[i] = line_order1[i];
		pid->Line_Num = pid->Line_Order[pid->Line_Cnt];
		flag = 1;
	}
	if(flag == 0 && dir == Left)
	{
		for(int i = 0;i < 24;i++) pid->Line_Order[i] = line_order2[i];
		pid->Line_Num = pid->Line_Order[pid->Line_Cnt];
		flag = 1;
	}
	if(pid->Line_Num < 17)
	{
		pid->direction = ACW;
		pid->Mode = Line;
		pid->Line_Num = pid->Line_Order[pid->Line_Cnt];
		PID_Control(pid);
		GO(pid);
		pid->Line_Cnt += 1;
		if(pid->Line_Cnt == 24) pid->Line_Cnt = 0;
		pid->Line_Num = pid->Line_Order[pid->Line_Cnt];
		PID_Pre(pid);
		if(pid->l->line_Error>1000) pid->Line_Cnt -= 1;
		if(pid->Line_Cnt == -1) pid->Line_Cnt = 23;
		pid->Line_Num = pid->Line_Order[pid->Line_Cnt];
		pid->target_Num = pid->Line_Num % 4 +1;
		if(pid->target_Num == 4) pid->target_Num = 0;
	}
	else if(pid->Line_Num > 16)
	{
		pid->direction = CW;
		pid->Mode = Line;
		pid->Line_Num = pid->Line_Order[pid->Line_Cnt];
		PID_Control(pid);
		GO(pid);
		pid->Line_Cnt += 1;
		if(pid->Line_Cnt == 24) pid->Line_Cnt = 0;
		pid->Line_Num = pid->Line_Order[pid->Line_Cnt];
		PID_Pre(pid);
		if(pid->l->line_Error<-1000) pid->Line_Cnt -= 1;
		if(pid->Line_Cnt == -1) pid->Line_Cnt = 23;
		pid->Line_Num = pid->Line_Order[pid->Line_Cnt];
		pid->target_Num = 3 - pid->Line_Num % 4;
	}
}
